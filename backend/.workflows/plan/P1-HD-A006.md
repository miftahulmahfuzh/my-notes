# Implementation Plan: P1-HD-A006

**TaskID**: P1-HD-A006
**Type**: Bug
**Created**: 2026-01-28 12:00:00
**Analysis Source**: User-reported 404 error on /api/v1/tags

---

## User Context

User reported a 404 error when the frontend tag autocomplete feature (P2-CN-A024) tries to call GET /api/v1/tags. The endpoint is commented out in server.go and the TagsHandler doesn't exist.

---

## Summary

The frontend tag autocomplete feature was just implemented, but the backend endpoint /api/v1/tags doesn't exist. The routes are commented out in server.go (lines 250-253) and there's no TagsHandler. Need to implement the missing backend infrastructure to support the autocomplete feature.

---

## Scope

### Files to Modify
- `backend/internal/services/tag_service.go` - Add GetAllTags method
- `backend/internal/handlers/tags.go` - Create new TagsHandler
- `backend/internal/handlers/handlers.go` - Add Tags field
- `backend/internal/server/server.go` - Initialize handler and register routes

### Dependencies
- None (uses existing database and models)

---

## Implementation Steps

### Step 1: Add GetAllTags method to TagService
**File**: `backend/internal/services/tag_service.go`

**Change**: Add method to get all tags for a user with pagination and note counts

**Code**:
```go
// GetAllTags retrieves all tags for the current user with pagination
func (s *TagService) GetAllTags(userID string, limit int, offset int) (*models.TagList, error) {
	ctx := context.Background()

	// Set defaults
	if limit <= 0 {
		limit = 100
	}
	if limit > 1000 {
		limit = 1000
	}
	if offset < 0 {
		offset = 0
	}

	// Query to get all tags with their note counts for this user
	// Note: Tags are global (not per-user), but we only want tags used by this user's notes
	query := `
		SELECT DISTINCT
			t.id,
			t.name,
			t.created_at,
			COUNT(nt.note_id) as note_count
		FROM tags t
		INNER JOIN note_tags nt ON t.id = nt.tag_id
		INNER JOIN notes n ON nt.note_id = n.id
		WHERE n.user_id = $1
		GROUP BY t.id, t.name, t.created_at
		ORDER BY t.name ASC
		LIMIT $2 OFFSET $3
	`

	rows, err := s.db.QueryContext(ctx, query, userID, limit, offset)
	if err != nil {
		return nil, fmt.Errorf("failed to query tags: %w", err)
	}
	defer rows.Close()

	var tags []models.TagResponse
	for rows.Next() {
		var tag models.TagResponse
		err := rows.Scan(&tag.ID, &tag.Name, &tag.CreatedAt, &tag.NoteCount)
		if err != nil {
			return nil, fmt.Errorf("failed to scan tag: %w", err)
		}
		tags = append(tags, tag)
	}

	if err = rows.Err(); err != nil {
		return nil, fmt.Errorf("error iterating tags: %w", err)
	}

	// Get total count
	var total int
	countQuery := `
		SELECT COUNT(DISTINCT t.id)
		FROM tags t
		INNER JOIN note_tags nt ON t.id = nt.tag_id
		INNER JOIN notes n ON nt.note_id = n.id
		WHERE n.user_id = $1
	`
	err = s.db.QueryRowContext(ctx, countQuery, userID).Scan(&total)
	if err != nil {
		return nil, fmt.Errorf("failed to count tags: %w", err)
	}

	return &models.TagList{
		Tags:   tags,
		Total:  total,
		Limit:  limit,
		Offset: offset,
		HasMore: offset + limit < total,
	}, nil
}
```

**Impact**: New public method that returns paginated tags with note counts

---

### Step 2: Create TagsHandler
**File**: `backend/internal/handlers/tags.go` (NEW FILE)

**Change**: Create new handler for tag-related endpoints

**Code**:
```go
package handlers

import (
	"encoding/json"
	"net/http"
	"strconv"

	"github.com/gpd/my-notes/internal/models"
	"github.com/gpd/my-notes/internal/services"
)

// TagsHandler handles tag-related HTTP requests
type TagsHandler struct {
	tagService services.TagServiceInterface
}

// NewTagsHandler creates a new TagsHandler instance
func NewTagsHandler(tagService services.TagServiceInterface) *TagsHandler {
	return &TagsHandler{
		tagService: tagService,
	}
}

// GetTags handles GET /api/v1/tags
func (h *TagsHandler) GetTags(w http.ResponseWriter, r *http.Request) {
	// Get user from context (set by auth middleware)
	user, ok := r.Context().Value("user").(*models.User)
	if !ok {
		respondWithError(w, http.StatusUnauthorized, "User not authenticated")
		return
	}

	// Parse query parameters
	limit, _ := strconv.Atoi(r.URL.Query().Get("limit"))
	if limit <= 0 {
		limit = 100
	}
	if limit > 1000 {
		limit = 1000
	}

	offset, _ := strconv.Atoi(r.URL.Query().Get("offset"))
	if offset < 0 {
		offset = 0
	}

	// Get tags for user
	tagList, err := h.tagService.GetAllTags(user.ID.String(), limit, offset)
	if err != nil {
		respondWithError(w, http.StatusInternalServerError, err.Error())
		return
	}

	respondWithJSON(w, http.StatusOK, tagList)
}
```

**Impact**: New handler file with GetTags endpoint

---

### Step 3: Add Tags to Handlers struct
**File**: `backend/internal/handlers/handlers.go`

**Change**: Add Tags field and SetTagsHandler method

**Code**:
```go
// Handlers groups all API handlers
type Handlers struct {
	Health     *HealthHandler
	Auth       *AuthHandler
	ChromeAuth *ChromeAuthHandler
	Notes      *NotesHandler
	Tags       *TagsHandler  // NEW FIELD
}

// NewHandlers creates a new handlers instance
func NewHandlers() *Handlers {
	return &Handlers{
		Health: NewHealthHandler(),
		Auth:   nil,
		Notes:  nil,
		Tags:   nil,  // NEW
	}
}

// SetTagsHandler initializes the tags handler with service dependencies
func (h *Handlers) SetTagsHandler(tagsHandler *TagsHandler) {
	h.Tags = tagsHandler
}
```

**Impact**: Adds Tags field to struct and initialization method

---

### Step 4: Initialize TagsHandler and register routes
**File**: `backend/internal/server/server.go`

**Change**: Initialize TagsHandler and uncomment/register the tag routes

**Code**:
```go
// In initializeServices() function, after noteService initialization:

// Initialize tags handler
tagsHandler := handlers.NewTagsHandler(tagService)

// Initialize auth handlers
s.handlers.SetAuthHandlers(authHandler, chromeAuthHandler)

// Initialize notes handler
s.handlers.SetNotesHandler(notesHandler)

// Initialize tags handler (NEW)
s.handlers.SetTagsHandler(tagsHandler)

// ... rest of function


// In setupRoutes() function, uncomment and modify:

// Tag routes
if s.handlers.Tags != nil {
	protected.HandleFunc("/tags", s.handlers.Tags.GetTags).Methods("GET")
}
```

**Impact**: TagsHandler is initialized and /tags route is registered

---

## Testing Plan
1. Build backend: `./backend_build.sh`
2. Start backend server
3. Call GET /api/v1/tags with valid auth token
4. Verify response returns tags list with pagination
5. Test with different limit/offset values
6. Test from frontend extension - autocomplete should work

## Rollback Plan
Delete `backend/internal/handlers/tags.go` and revert changes to other files if implementation fails.
